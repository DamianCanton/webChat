üöÄ Roadmap & Arquitectura: Refactorizaci√≥n a Context API

Base: Repositorio de Referencia (matu-dev-js) 


Este documento detalla la transici√≥n de una arquitectura de props b√°sica a una arquitectura profesional escalable basada en Context API para la gesti√≥n del estado global.

1. An√°lisis de Arquitectura y Estructura 

Estructura de Carpetas Objetivo
El proyecto debe reflejar esta organizaci√≥n para separar responsabilidades :

src/

Components/


ContactList/ ‚Üí Consume ContactListContext 


MessagesList/ ‚Üí Renderiza la lista de burbujas de chat 


NewMessageForm/ ‚Üí Formulario de env√≠o (invoca callback del Context) 

Context/


ContactListContext.jsx ‚Üí Maneja la lista de contactos (Sidebar) 


ContactDetailContext.jsx ‚Üí Maneja el chat activo y env√≠o de mensajes 

Screens/


HomeScreen/ ‚Üí Vista inicial (Lista + Placeholder) 


MessageScreen/ ‚Üí Vista de chat (Lista + Chat + Form) 

services/


contactService.js ‚Üí Simulaci√≥n de fetch de datos (API) 


App.jsx ‚Üí Router y Providers 

Patrones de Dise√±o Clave
Esta arquitectura implementa tres patrones fundamentales:


Context como "Store" (Separaci√≥n de Intereses): 

Desacopla la l√≥gica de la vista. Los componentes (Screens) no saben c√≥mo se buscan los datos ni c√≥mo se agregan mensajes; solo consumen el contexto.


Ejemplo: ContactDetailContext expone contactDetailed, isLoading y la funci√≥n onCreateNewMessage.


Layout Persistente (Simulado): 

Tanto HomeScreen como MessageScreen renderizan <ContactList />. Esto crea la ilusi√≥n de una "Single Page Application" donde la barra lateral es fija mientras cambia el contenido principal.


Simulaci√≥n de Asincron√≠a: 

Uso de setTimeout dentro de los Contexts para simular latencia de red (Network latency) y manejo de estados de carga (isLoading).

2. Roadmap de Implementaci√≥n (Hitos) 

Tu objetivo es refactorizar el c√≥digo actual para adoptar estos patrones.

‚úÖ HITO 1: Contexto de Lista (Sidebar) 


Objetivo: Que la lista de contactos sea global y accesible desde cualquier pantalla.


Crear src/Context/ContactListContext.jsx: 

Mover la l√≥gica de getContacts() aqu√≠.

Crear los estados contactList y isLoading.

Usar useEffect para cargar datos (simulando delay) .


Refactorizar ContactList.jsx: 

Eliminar recepci√≥n de props.

Implementar useContext(ContactListContext).


Provider en App.jsx: 

Envolver las rutas con <ContactListContextProvider>.

‚úÖ HITO 2: Contexto de Detalle y L√≥gica de Chat 


Objetivo: Manejar la conversaci√≥n activa y el env√≠o de mensajes (El "cerebro" del chat).



Crear src/Context/ContactDetailContext.jsx: 

Debe leer el ID de la URL usando useParams.

Debe exponer la funci√≥n onCreateNewMessage(text).


Refactorizar MessageScreen.jsx: 

Consumir contactDetailed y pasarlo a <MessagesList />.

Pasar onCreateNewMessage a <NewMessageForm />.

‚úÖ HITO 3: El "Bot" (Respuesta Autom√°tica) 


Objetivo: Cumplir con el requisito de respuesta autom√°tica.


Ubicaci√≥n: Dentro de ContactDetailContext.jsx, en la funci√≥n onCreateNewMessage.

L√≥gica:

Agregar mensaje del usuario al estado.

Lanzar un setTimeout.

Dentro del timeout, agregar un nuevo mensaje con author: 'IA' (o nombre del contacto).

‚úÖ HITO 4: Funcionalidades Extras 


Buscador (Search): 

En ContactListContext, agregar estado searchQuery y funci√≥n handleSearch.

Filtrar el array contactList antes de pasarlo al Provider .



3. Tu Primera Misi√≥n: El Contexto de Detalle 

Para conectar todo, el paso inmediato es crear el contexto que te falta.


Tarea: Crea el archivo src/Context/ContactDetailContext.jsx bas√°ndote en el siguiente esqueleto.

Nota T√©cnica: He corregido errores de sintaxis del PDF original (como espacios en nombres de funciones) para que el c√≥digo sea funcional.

JavaScript

import { createContext, useState, useEffect } from "react";
import { useParams } from "react-router-dom";
import { getContactById } from "../Services/contactService"; // [cite: 74]

export const ContactDetailContext = createContext(); // [cite: 75]

export const ContactDetailContextProvider = ({ children }) => { // [cite: 76]
    const { contact_id } = useParams();
    const [contactDetailed, setContactDetailed] = useState(null); // [cite: 77]

    useEffect(() => {
        // L√≥gica para cargar el contacto cuando cambia contact_id
        const data = getContactById(contact_id); // [cite: 79]
        setContactDetailed(data); // [cite: 80]
    }, [contact_id]); // [cite: 81]

    const handleAddNewMessage = (text) => { // [cite: 82]
        // Aqu√≠ va la l√≥gica para agregar mensaje y luego la respuesta del bot
        console.log("Nuevo mensaje:", text); // [cite: 84]
        
        // TODO: Implementar l√≥gica de estado y setTimeout para Hito 3
    };

    return (
        <ContactDetailContext.Provider value={{ contactDetailed, handleAddNewMessage }}>
            {children}
        </ContactDetailContext.Provider> // [cite: 88]
    );
};